<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QabÅ¼a Sa L-AÄ§Ä§ar</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        #game-container {
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border-radius: 8px;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <script>
        // Global game data with localStorage persistence
        const GameData = {
            selectedSkin: localStorage.getItem('selectedSkin') || 'red_square',
            highScore: parseInt(localStorage.getItem('highScore')) || 0,
            unlockedSkins: JSON.parse(localStorage.getItem('unlockedSkins')) || ['red_square'],
            completedLevels: JSON.parse(localStorage.getItem('completedLevels')) || [],
            currentLevel: 1,

            levels: {
                1: {
                    name: 'Forest Realm',
                    theme: { sky: '#87CEEB', ground: '#8B4513', obstacle: '#228B22' },
                    length: 1500,
                    obstacles: [300, 500, 700, 900, 1200],
                    background: 'forest'
                },
                2: {
                    name: 'Desert Wasteland',
                    theme: { sky: '#FFE4B5', ground: '#DEB887', obstacle: '#CD853F' },
                    length: 1800,
                    obstacles: [300, 550, 750, 1000, 1250, 1500],
                    background: 'desert'
                },
                3: {
                    name: 'Ice Mountains',
                    theme: { sky: '#B0E0E6', ground: '#E0FFFF', obstacle: '#87CEEB' },
                    length: 2000,
                    obstacles: [250, 500, 700, 950, 1200, 1450, 1700],
                    background: 'ice'
                },
                4: {
                    name: 'Volcanic Caves',
                    theme: { sky: '#2F4F4F', ground: '#696969', obstacle: '#DC143C' },
                    length: 2200,
                    obstacles: [300, 500, 700, 900, 1100, 1400, 1700, 1950],
                    background: 'volcano'
                },
                5: {
                    name: 'Sky Kingdom',
                    theme: { sky: '#87CEFA', ground: '#FFFAF0', obstacle: '#DDA0DD' },
                    length: 2400,
                    obstacles: [250, 480, 680, 900, 1150, 1380, 1620, 1850, 2100],
                    background: 'sky'
                },
                6: {
                    name: 'Neon City',
                    theme: { sky: '#191970', ground: '#2F4F4F', obstacle: '#FF1493' },
                    length: 2600,
                    obstacles: [300, 520, 740, 960, 1180, 1400, 1650, 1900, 2150, 2400],
                    background: 'neon'
                },
                7: {
                    name: 'Toxic Swamp',
                    theme: { sky: '#556B2F', ground: '#6B8E23', obstacle: '#9ACD32' },
                    length: 2800,
                    obstacles: [280, 500, 720, 940, 1160, 1400, 1640, 1880, 2140, 2400, 2600],
                    background: 'swamp'
                },
                8: {
                    name: 'Crystal Caves',
                    theme: { sky: '#483D8B', ground: '#9370DB', obstacle: '#BA55D3' },
                    length: 3000,
                    obstacles: [300, 500, 720, 920, 1140, 1380, 1600, 1840, 2080, 2340, 2600, 2850],
                    background: 'crystal'
                },
                9: {
                    name: 'Final Dimension',
                    theme: { sky: '#000000', ground: '#1C1C1C', obstacle: '#FFD700' },
                    length: 3500,
                    obstacles: [250, 450, 650, 850, 1050, 1280, 1510, 1740, 1970, 2200, 2450, 2700, 2950, 3200],
                    background: 'space'
                }
            },

            skins: {
                'red_square': { name: 'Classic Red', color: 0xFF0000, shape: 'square', unlockScore: 0, description: 'Starter skin' },
                'blue_circle': { name: 'Blue Blob', color: 0x0000FF, shape: 'circle', unlockScore: 50, description: 'Score 50 to unlock' },
                'green_square': { name: 'Green Machine', color: 0x00FF00, shape: 'square', unlockScore: 100, description: 'Score 100 to unlock' },
                'yellow_triangle': { name: 'Yellow Arrow', color: 0xFFFF00, shape: 'triangle', unlockScore: 150, description: 'Score 150 to unlock' },
                'purple_circle': { name: 'Purple Orb', color: 0xFF00FF, shape: 'circle', unlockScore: 200, description: 'Score 200 to unlock' },
                'orange_square': { name: 'Orange Box', color: 0xFF8800, shape: 'square', unlockScore: 300, description: 'Score 300 to unlock' },
                'cyan_circle': { name: 'Cyan Sphere', color: 0x00FFFF, shape: 'circle', unlockScore: 400, description: 'Score 400 to unlock' },
                'pink_square': { name: 'Pink Cube', color: 0xFF69B4, shape: 'square', unlockScore: 500, description: 'Score 500 to unlock' }
            },

            saveData() {
                localStorage.setItem('selectedSkin', this.selectedSkin);
                localStorage.setItem('highScore', this.highScore);
                localStorage.setItem('unlockedSkins', JSON.stringify(this.unlockedSkins));
                localStorage.setItem('completedLevels', JSON.stringify(this.completedLevels));
            },

            updateHighScore(score) {
                if (score > this.highScore) {
                    this.highScore = score;
                    this.checkUnlocks(score);
                    this.saveData();
                    return true;
                }
                return false;
            },

            completeLevel(levelNum) {
                if (!this.completedLevels.includes(levelNum)) {
                    this.completedLevels.push(levelNum);
                    this.saveData();
                }
            },

            isLevelUnlocked(levelNum) {
                if (levelNum === 1) return true;
                return this.completedLevels.includes(levelNum - 1);
            },

            checkUnlocks(score) {
                const newUnlocks = [];
                Object.keys(this.skins).forEach(skinKey => {
                    const skin = this.skins[skinKey];
                    if (score >= skin.unlockScore && !this.unlockedSkins.includes(skinKey)) {
                        this.unlockedSkins.push(skinKey);
                        newUnlocks.push(skin.name);
                    }
                });
                return newUnlocks;
            },

            isSkinUnlocked(skinKey) {
                return this.unlockedSkins.includes(skinKey);
            }
        };

        // MENU SCENE
        class MenuScene extends Phaser.Scene {
            constructor() {
                super('MenuScene');
            }

            create() {
                this.cameras.main.setBackgroundColor('#87CEEB');

                this.add.text(400, 70, 'QABÅ»A SA L-AÄ¦Ä¦AR', {
                    fontSize: '72px',
                    fill: '#FF0000',
                    fontStyle: 'bold',
                    stroke: '#000',
                    strokeThickness: 8
                }).setOrigin(0.5);

                const totalLevels = Object.keys(GameData.levels).length;
                const completedCount = GameData.completedLevels.length;

                this.add.text(400, 150, 'Levels Completed: ' + completedCount + '/' + totalLevels, {
                    fontSize: '20px',
                    fill: '#FFD700',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                this.add.text(400, 180, 'High Score: ' + GameData.highScore, {
                    fontSize: '18px',
                    fill: '#00FF00',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                const playButton = this.add.rectangle(400, 260, 220, 60, 0x00FF00);
                this.add.text(400, 260, 'PLAY LEVELS', {
                    fontSize: '28px',
                    fill: '#000',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                playButton.setInteractive({ useHandCursor: true });
                playButton.on('pointerover', () => { playButton.fillColor = 0x00DD00; });
                playButton.on('pointerout', () => { playButton.fillColor = 0x00FF00; });
                playButton.on('pointerdown', () => { this.scene.start('LevelSelectScene'); });

                const skinsButton = this.add.rectangle(400, 340, 220, 60, 0xFFAA00);
                this.add.text(400, 340, 'CHOOSE SKIN', {
                    fontSize: '28px',
                    fill: '#000',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                skinsButton.setInteractive({ useHandCursor: true });
                skinsButton.on('pointerover', () => { skinsButton.fillColor = 0xFF8800; });
                skinsButton.on('pointerout', () => { skinsButton.fillColor = 0xFFAA00; });
                skinsButton.on('pointerdown', () => { this.scene.start('SkinsScene'); });

                this.add.text(400, 430, 'HOW TO PLAY', {
                    fontSize: '20px',
                    fill: '#000',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                this.add.text(400, 465, 'â† â†’ Arrow Keys: Move  |  SPACE: Jump', {
                    fontSize: '14px',
                    fill: '#000'
                }).setOrigin(0.5);

                this.add.text(400, 490, 'Reach the end of each level!', {
                    fontSize: '14px',
                    fill: '#00FF00',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                this.add.text(400, 515, 'Complete levels to unlock the next one!', {
                    fontSize: '13px',
                    fill: '#FF0000'
                }).setOrigin(0.5);

                const currentSkin = GameData.skins[GameData.selectedSkin];
                this.add.text(400, 560, 'Current Skin: ' + currentSkin.name, {
                    fontSize: '14px',
                    fill: '#666'
                }).setOrigin(0.5);

                this.input.keyboard.once('keydown-SPACE', () => {
                    this.scene.start('LevelSelectScene');
                });
            }
        }

        // LEVEL SELECT SCENE
        class LevelSelectScene extends Phaser.Scene {
            constructor() {
                super('LevelSelectScene');
            }

            create() {
                this.cameras.main.setBackgroundColor('#87CEEB');

                this.add.text(400, 40, 'SELECT LEVEL', {
                    fontSize: '48px',
                    fill: '#000',
                    fontStyle: 'bold',
                    stroke: '#FFF',
                    strokeThickness: 4
                }).setOrigin(0.5);

                const levelKeys = Object.keys(GameData.levels);
                const startX = 200;
                const startY = 120;
                const spacingX = 130;
                const spacingY = 140;

                levelKeys.forEach((levelNum, index) => {
                    const level = GameData.levels[levelNum];
                    const col = index % 4;
                    const row = Math.floor(index / 4);
                    const x = startX + col * spacingX;
                    const y = startY + row * spacingY;

                    const isUnlocked = GameData.isLevelUnlocked(parseInt(levelNum));
                    const isCompleted = GameData.completedLevels.includes(parseInt(levelNum));

                    const bgColor = isCompleted ? 0xFFD700 : (isUnlocked ? 0x00FF00 : 0x666666);
                    const bg = this.add.rectangle(x, y, 110, 110, bgColor, isUnlocked ? 0.3 : 0.5);

                    const numberBg = this.add.circle(x, y - 15, 30, isUnlocked ? 0xFFFFFF : 0x333333);
                    this.add.text(x, y - 15, levelNum, {
                        fontSize: '32px',
                        fill: '#000',
                        fontStyle: 'bold'
                    }).setOrigin(0.5);

                    if (isCompleted) {
                        this.add.text(x + 35, y - 45, 'âœ“', {
                            fontSize: '24px',
                            fill: '#00FF00',
                            fontStyle: 'bold'
                        }).setOrigin(0.5);
                    }

                    if (!isUnlocked) {
                        this.add.text(x, y - 15, 'ðŸ”’', {
                            fontSize: '24px'
                        }).setOrigin(0.5);
                    }

                    this.add.text(x, y + 30, level.name, {
                        fontSize: '11px',
                        fill: '#000',
                        fontStyle: 'bold',
                        align: 'center',
                        wordWrap: { width: 100 }
                    }).setOrigin(0.5);

                    if (isUnlocked) {
                        bg.setInteractive({ useHandCursor: true });
                        bg.on('pointerover', () => { bg.alpha = 0.6; });
                        bg.on('pointerout', () => { bg.alpha = 0.3; });
                        bg.on('pointerdown', () => {
                            GameData.currentLevel = parseInt(levelNum);
                            this.scene.start('GameScene');
                        });
                    }
                });

                const backButton = this.add.rectangle(400, 540, 180, 50, 0xFF0000);
                this.add.text(400, 540, 'BACK TO MENU', {
                    fontSize: '24px',
                    fill: '#FFF',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                backButton.setInteractive({ useHandCursor: true });
                backButton.on('pointerover', () => { backButton.fillColor = 0xDD0000; });
                backButton.on('pointerout', () => { backButton.fillColor = 0xFF0000; });
                backButton.on('pointerdown', () => { this.scene.start('MenuScene'); });

                this.input.keyboard.once('keydown-ESC', () => {
                    this.scene.start('MenuScene');
                });
            }
        }

        // SKINS SELECTION SCENE (keeping same as before)
        class SkinsScene extends Phaser.Scene {
            constructor() {
                super('SkinsScene');
            }

            create() {
                this.cameras.main.setBackgroundColor('#87CEEB');

                this.add.text(400, 40, 'CHOOSE YOUR SKIN', {
                    fontSize: '42px',
                    fill: '#000',
                    fontStyle: 'bold',
                    stroke: '#FFF',
                    strokeThickness: 4
                }).setOrigin(0.5);

                this.add.text(400, 85, 'High Score: ' + GameData.highScore, {
                    fontSize: '18px',
                    fill: '#FFD700',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                const skinKeys = Object.keys(GameData.skins);
                const startX = 150;
                const startY = 140;
                const spacing = 150;

                skinKeys.forEach((skinKey, index) => {
                    const skin = GameData.skins[skinKey];
                    const col = index % 4;
                    const row = Math.floor(index / 4);
                    const x = startX + col * spacing;
                    const y = startY + row * spacing;

                    const isUnlocked = GameData.isSkinUnlocked(skinKey);
                    const isSelected = skinKey === GameData.selectedSkin;

                    const bgColor = isUnlocked ? 0xFFFFFF : 0x666666;
                    const bg = this.add.rectangle(x, y, 120, 120, bgColor, isUnlocked ? 0.3 : 0.5);

                    if (isSelected && isUnlocked) {
                        const highlight = this.add.rectangle(x, y, 130, 130);
                        highlight.setStrokeStyle(4, 0xFFFF00);
                    }

                    let skinPreview;
                    const skinColor = isUnlocked ? skin.color : 0x333333;

                    if (skin.shape === 'square') {
                        skinPreview = this.add.rectangle(x, y - 20, 40, 40, skinColor);
                    } else if (skin.shape === 'circle') {
                        skinPreview = this.add.circle(x, y - 20, 20, skinColor);
                    } else if (skin.shape === 'triangle') {
                        skinPreview = this.add.triangle(x, y - 20, 0, 20, -20, -20, 20, -20, skinColor);
                    }

                    if (!isUnlocked) {
                        this.add.text(x, y - 20, 'ðŸ”’', { fontSize: '30px' }).setOrigin(0.5);
                    }

                    this.add.text(x, y + 20, skin.name, {
                        fontSize: '11px',
                        fill: '#000',
                        fontStyle: 'bold',
                        align: 'center',
                        wordWrap: { width: 110 }
                    }).setOrigin(0.5);

                    if (!isUnlocked) {
                        this.add.text(x, y + 38, 'Score ' + skin.unlockScore, {
                            fontSize: '10px',
                            fill: '#FF0000',
                            fontStyle: 'bold',
                            align: 'center'
                        }).setOrigin(0.5);
                    } else {
                        this.add.text(x, y + 38, 'âœ“ Unlocked', {
                            fontSize: '10px',
                            fill: '#00FF00',
                            fontStyle: 'bold',
                            align: 'center'
                        }).setOrigin(0.5);
                    }

                    if (isUnlocked) {
                        bg.setInteractive({ useHandCursor: true });
                        bg.on('pointerover', () => {
                            bg.fillColor = 0xFFFFFF;
                            bg.alpha = 0.6;
                        });
                        bg.on('pointerout', () => {
                            bg.fillColor = 0xFFFFFF;
                            bg.alpha = 0.3;
                        });
                        bg.on('pointerdown', () => {
                            GameData.selectedSkin = skinKey;
                            GameData.saveData();
                            this.scene.restart();
                        });
                    }
                });

                const backButton = this.add.rectangle(400, 540, 180, 50, 0xFF0000);
                this.add.text(400, 540, 'BACK TO MENU', {
                    fontSize: '24px',
                    fill: '#FFF',
                    fontStyle: 'bold'
                }).setOrigin(0.5);

                backButton.setInteractive({ useHandCursor: true });
                backButton.on('pointerover', () => { backButton.fillColor = 0xDD0000; });
                backButton.on('pointerout', () => { backButton.fillColor = 0xFF0000; });
                backButton.on('pointerdown', () => { this.scene.start('MenuScene'); });

                this.input.keyboard.once('keydown-ESC', () => {
                    this.scene.start('MenuScene');
                });
            }
        }

        // GAME SCENE
        class GameScene extends Phaser.Scene {
            constructor() {
                super('GameScene');
            }

            create() {
                const levelData = GameData.levels[GameData.currentLevel];
                const theme = levelData.theme;

                this.score = 0;
                this.lives = 5;
                this.playerSpeed = 300;
                this.canDoubleJump = true;
                this.hasDoubleJumped = false;
                this.isGameOver = false;
                this.levelCompleted = false;

                this.cameras.main.setBackgroundColor(theme.sky);

                // CREATE BACKGROUND
                this.createBackground(levelData.background, levelData.length);

                this.physics.world.setBounds(0, 0, levelData.length + 500, 600);

                // Create ground
                this.ground = this.physics.add.staticGroup();
                const groundTiles = Math.ceil((levelData.length + 500) / 80);
                for (let i = 0; i < groundTiles; i++) {
                    const groundTile = this.add.rectangle(i * 80, 580, 80, 40, parseInt(theme.ground.replace('#', '0x')));
                    this.ground.add(groundTile);
                }

                // Create finish line
                this.finishLine = this.add.rectangle(levelData.length, 400, 20, 400, 0xFFD700);
                this.physics.add.existing(this.finishLine, true);
                this.add.text(levelData.length, 300, 'FINISH!', {
                    fontSize: '48px',
                    fill: '#FFD700',
                    fontStyle: 'bold',
                    stroke: '#000',
                    strokeThickness: 4
                }).setOrigin(0.5);

                // Create player
                const selectedSkin = GameData.skins[GameData.selectedSkin];
                if (selectedSkin.shape === 'square') {
                    this.player = this.add.rectangle(100, 500, 30, 30, selectedSkin.color);
                } else if (selectedSkin.shape === 'circle') {
                    this.player = this.add.circle(100, 500, 15, selectedSkin.color);
                } else if (selectedSkin.shape === 'triangle') {
                    this.player = this.add.triangle(100, 500, 0, 15, -15, -15, 15, -15, selectedSkin.color);
                }

                this.physics.add.existing(this.player);
                this.player.body.setCollideWorldBounds(true);
                this.playerOriginalColor = selectedSkin.color;

                // Create obstacles
                this.obstacles = this.physics.add.staticGroup();
                levelData.obstacles.forEach(xPos => {
                    this.createObstacle(xPos, theme.obstacle);
                });

                // Collisions
                this.physics.add.collider(this.player, this.ground);
                this.physics.add.overlap(this.player, this.obstacles, this.hitObstacle, null, this);
                this.physics.add.overlap(this.player, this.finishLine, this.completeLevel, null, this);

                // Input
                this.cursors = this.input.keyboard.createCursorKeys();
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.input.on('pointerdown', () => this.jump());

                // Camera
                this.cameras.main.setBounds(0, 0, levelData.length + 500, 600);
                this.cameras.main.startFollow(this.player);

                // UI
                this.add.text(400, 16, 'Level ' + GameData.currentLevel + ': ' + levelData.name, {
                    fontSize: '24px',
                    fill: '#000',
                    fontStyle: 'bold',
                    stroke: '#FFF',
                    strokeThickness: 3
                }).setOrigin(0.5, 0).setScrollFactor(0);

                this.livesText = this.add.text(16, 16, 'Lives: 5', {
                    fontSize: '24px',
                    fill: '#000',
                    fontStyle: 'bold'
                }).setScrollFactor(0);

                this.scoreText = this.add.text(16, 50, 'Score: 0', {
                    fontSize: '20px',
                    fill: '#000',
                    fontStyle: 'bold'
                }).setScrollFactor(0);

                console.log('Level ' + GameData.currentLevel + ' started!');
            }

            createBackground(backgroundType, levelLength) {
                // Create background elements based on theme
                switch(backgroundType) {
                    case 'forest':
                        // Trees
                        for (let i = 0; i < levelLength / 200; i++) {
                            const x = i * 200 + 100;
                            this.add.rectangle(x, 520, 20, 80, 0x8B4513).setScrollFactor(0.5);
                            this.add.circle(x, 480, 40, 0x228B22).setScrollFactor(0.5);
                        }
                        // Clouds
                        for (let i = 0; i < 5; i++) {
                            const x = i * 400;
                            this.add.ellipse(x + 100, 80, 80, 40, 0xFFFFFF, 0.7).setScrollFactor(0.2);
                        }
                        break;

                    case 'desert':
                        // Sun
                        this.add.circle(700, 80, 50, 0xFFFF00).setScrollFactor(0.1);
                        // Sand dunes
                        for (let i = 0; i < levelLength / 300; i++) {
                            const x = i * 300;
                            this.add.ellipse(x + 150, 500, 200, 100, 0xF4A460, 0.5).setScrollFactor(0.4);
                        }
                        // Cacti
                        for (let i = 0; i < levelLength / 400; i++) {
                            const x = i * 400 + 200;
                            this.add.rectangle(x, 520, 15, 60, 0x228B22).setScrollFactor(0.6);
                        }
                        break;

                    case 'ice':
                        // Snowflakes
                        for (let i = 0; i < 20; i++) {
                            const x = Phaser.Math.Between(0, 800);
                            const y = Phaser.Math.Between(50, 300);
                            this.add.star(x, y, 6, 3, 6, 0xFFFFFF).setScrollFactor(0.3);
                        }
                        // Mountains
                        for (let i = 0; i < 5; i++) {
                            const x = i * 300;
                            this.add.triangle(x + 150, 550, 0, 0, -100, 200, 100, 200, 0xE0FFFF, 0.6).setScrollFactor(0.3);
                        }
                        break;

                    case 'volcano':
                        // Lava glow
                        for (let i = 0; i < levelLength / 200; i++) {
                            const x = i * 200;
                            this.add.circle(x, 560, 30, 0xFF4500, 0.3).setScrollFactor(0.8);
                        }
                        // Smoke/ash
                        for (let i = 0; i < 10; i++) {
                            const x = Phaser.Math.Between(0, 800);
                            const y = Phaser.Math.Between(50, 300);
                            this.add.circle(x, y, 20, 0x696969, 0.4).setScrollFactor(0.2);
                        }
                        // Rock formations
                        for (let i = 0; i < levelLength / 350; i++) {
                            const x = i * 350 + 100;
                            this.add.triangle(x, 550, 0, 0, -40, 100, 40, 100, 0x2F4F4F, 0.7).setScrollFactor(0.5);
                        }
                        break;

                    case 'sky':
                        // Clouds
                        for (let i = 0; i < levelLength / 150; i++) {
                            const x = i * 150;
                            const y = Phaser.Math.Between(100, 400);
                            this.add.ellipse(x, y, 120, 60, 0xFFFFFF, 0.8).setScrollFactor(0.4);
                        }
                        // Birds
                        for (let i = 0; i < 8; i++) {
                            const x = i * 200 + 50;
                            const y = Phaser.Math.Between(80, 250);
                            this.add.text(x, y, 'V', { fontSize: '20px', fill: '#000' }).setScrollFactor(0.3);
                        }
                        // Rainbow
                        const colors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3];
                        for (let i = 0; i < 7; i++) {
                            this.add.arc(400, 600, 200 + i * 10, 180, 0, false, colors[i], 0.3).setScrollFactor(0.1);
                        }
                        break;

                    case 'neon':
                        // City buildings
                        for (let i = 0; i < levelLength / 200; i++) {
                            const x = i * 200;
                            const height = Phaser.Math.Between(150, 350);
                            this.add.rectangle(x + 100, 550 - height/2, 80, height, 0x1C1C1C, 0.8).setScrollFactor(0.6);
                            // Windows
                            for (let w = 0; w < 5; w++) {
                                const windowY = 550 - height + w * 40 + 20;
                                this.add.rectangle(x + 90, windowY, 15, 15, 0xFFFF00, 0.8).setScrollFactor(0.6);
                                this.add.rectangle(x + 110, windowY, 15, 15, 0xFF00FF, 0.8).setScrollFactor(0.6);
                            }
                        }
                        // Stars
                        for (let i = 0; i < 30; i++) {
                            const x = Phaser.Math.Between(0, levelLength);
                            const y = Phaser.Math.Between(20, 200);
                            this.add.star(x, y, 5, 2, 4, 0xFFFFFF).setScrollFactor(0.1);
                        }
                        break;

                    case 'swamp':
                        // Dead trees
                        for (let i = 0; i < levelLength / 250; i++) {
                            const x = i * 250 + 120;
                            this.add.rectangle(x, 490, 15, 120, 0x4A4A4A).setScrollFactor(0.7);
                            this.add.line(x, 460, 0, 0, -30, -40, 0x4A4A4A, 0.8).setLineWidth(5).setScrollFactor(0.7);
                            this.add.line(x, 460, 0, 0, 30, -40, 0x4A4A4A, 0.8).setLineWidth(5).setScrollFactor(0.7);
                        }
                        // Fog/mist
                        for (let i = 0; i < 8; i++) {
                            const x = i * 200;
                            this.add.ellipse(x + 100, 450, 150, 60, 0x9ACD32, 0.2).setScrollFactor(0.5);
                        }
                        break;

                    case 'crystal':
                        // Crystals
                        for (let i = 0; i < levelLength / 200; i++) {
                            const x = i * 200 + 100;
                            const y = Phaser.Math.Between(350, 500);
                            const size = Phaser.Math.Between(30, 60);
                            this.add.triangle(x, y, 0, -size, -size/2, size/2, size/2, size/2, 0xBA55D3, 0.6).setScrollFactor(0.5);
                        }
                        // Glowing particles
                        for (let i = 0; i < 25; i++) {
                            const x = Phaser.Math.Between(0, levelLength);
                            const y = Phaser.Math.Between(100, 500);
                            this.add.circle(x, y, 3, 0xFF00FF, 0.8).setScrollFactor(0.3);
                        }
                        break;

                    case 'space':
                        // Stars
                        for (let i = 0; i < 100; i++) {
                            const x = Phaser.Math.Between(0, levelLength);
                            const y = Phaser.Math.Between(20, 550);
                            const size = Phaser.Math.Between(1, 3);
                            this.add.circle(x, y, size, 0xFFFFFF).setScrollFactor(0.1);
                        }
                        // Planets
                        this.add.circle(300, 150, 40, 0xFF6347).setScrollFactor(0.2);
                        this.add.circle(1200, 200, 60, 0x4169E1).setScrollFactor(0.15);
                        this.add.circle(2000, 120, 35, 0x9370DB).setScrollFactor(0.18);
                        // Nebula
                        for (let i = 0; i < 5; i++) {
                            const x = i * 600 + 200;
                            this.add.ellipse(x, 300, 200, 150, 0x8B008B, 0.2).setScrollFactor(0.1);
                        }
                        // Comets/shooting stars
                        for (let i = 0; i < 3; i++) {
                            const x = i * 800 + 400;
                            const y = Phaser.Math.Between(100, 300);
                            this.add.line(x, y, 0, 0, -50, 20, 0xFFD700, 0.6).setLineWidth(3).setScrollFactor(0.25);
                        }
                        break;
                }
            }

            update() {
                if (this.isGameOver || this.levelCompleted) return;

                this.score += 1;
                this.scoreText.setText('Score: ' + Math.floor(this.score / 10));

                if (this.cursors.left.isDown) {
                    this.player.body.setVelocityX(-this.playerSpeed);
                } else if (this.cursors.right.isDown) {
                    this.player.body.setVelocityX(this.playerSpeed);
                } else {
                    this.player.body.setVelocityX(0);
                }

                if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                    this.jump();
                }

                if (this.player.body.touching.down) {
                    this.hasDoubleJumped = false;
                }
            }

            jump() {
                if (this.isGameOver || this.levelCompleted) return;

                if (this.player.body.touching.down) {
                    this.player.body.setVelocityY(-500);
                    this.hasDoubleJumped = false;
                } else if (this.canDoubleJump && !this.hasDoubleJumped) {
                    this.player.body.setVelocityY(-450);
                    this.hasDoubleJumped = true;
                }
            }

            createObstacle(xPosition, color) {
                const height = Phaser.Math.Between(30, 60);
                const obstacle = this.add.rectangle(xPosition, 550 - height / 2, 30, height, parseInt(color.replace('#', '0x')));
                this.obstacles.add(obstacle);
            }

            hitObstacle(player, obstacle) {
                obstacle.destroy();
                this.lives -= 1;
                this.livesText.setText('Lives: ' + this.lives);

                player.fillColor = 0xFFFFFF;
                this.time.delayedCall(100, () => {
                    if (!this.isGameOver) {
                        player.fillColor = this.playerOriginalColor;
                    }
                });

                if (this.lives <= 0) {
                    this.gameOver();
                }
            }

            completeLevel() {
                if (this.levelCompleted) return;

                this.levelCompleted = true;
                this.physics.pause();

                const finalScore = Math.floor(this.score / 10);
                GameData.completeLevel(GameData.currentLevel);
                const isNewHighScore = GameData.updateHighScore(finalScore);

                this.add.text(400, 200, 'LEVEL COMPLETE!', {
                    fontSize: '64px',
                    fill: '#FFD700',
                    fontStyle: 'bold',
                    stroke: '#000',
                    strokeThickness: 8
                }).setOrigin(0.5).setScrollFactor(0);

                this.add.text(400, 280, 'Score: ' + finalScore, {
                    fontSize: '32px',
                    fill: '#000',
                    fontStyle: 'bold'
                }).setOrigin(0.5).setScrollFactor(0);

                if (isNewHighScore) {
                    this.add.text(400, 320, 'ðŸ† NEW HIGH SCORE! ðŸ†', {
                        fontSize: '24px',
                        fill: '#FFD700',
                        fontStyle: 'bold'
                    }).setOrigin(0.5).setScrollFactor(0);
                }

                const hasNextLevel = GameData.levels[GameData.currentLevel + 1];
                if (hasNextLevel) {
                    const nextButton = this.add.rectangle(300, 400, 200, 60, 0x00FF00).setScrollFactor(0);
                    this.add.text(300, 400, 'NEXT LEVEL', {
                        fontSize: '28px',
                        fill: '#000',
                        fontStyle: 'bold'
                    }).setOrigin(0.5).setScrollFactor(0);

                    nextButton.setInteractive({ useHandCursor: true });
                    nextButton.on('pointerover', () => { nextButton.fillColor = 0x00DD00; });
                    nextButton.on('pointerout', () => { nextButton.fillColor = 0x00FF00; });
                    nextButton.on('pointerdown', () => {
                        GameData.currentLevel++;
                        this.scene.restart();
                    });
                }

                const menuButton = this.add.rectangle(500, 400, 200, 60, 0xFF0000).setScrollFactor(0);
                this.add.text(500, 400, 'LEVEL SELECT', {
                    fontSize: '28px',
                    fill: '#FFF',
                    fontStyle: 'bold'
                }).setOrigin(0.5).setScrollFactor(0);

                menuButton.setInteractive({ useHandCursor: true });
                menuButton.on('pointerover', () => { menuButton.fillColor = 0xDD0000; });
                menuButton.on('pointerout', () => { menuButton.fillColor = 0xFF0000; });
                menuButton.on('pointerdown', () => { this.scene.start('LevelSelectScene'); });
            }

            gameOver() {
                this.isGameOver = true;
                this.physics.pause();
                this.player.fillColor = 0x666666;

                const finalScore = Math.floor(this.score / 10);
                GameData.updateHighScore(finalScore);

                this.add.text(400, 250, 'GAME OVER', {
                    fontSize: '64px',
                    fill: '#FF0000',
                    fontStyle: 'bold',
                    stroke: '#000',
                    strokeThickness: 8
                }).setOrigin(0.5).setScrollFactor(0);

                this.add.text(400, 340, 'Score: ' + finalScore, {
                    fontSize: '32px',
                    fill: '#000',
                    fontStyle: 'bold'
                }).setOrigin(0.5).setScrollFactor(0);

                const retryButton = this.add.rectangle(300, 440, 200, 60, 0x00FF00).setScrollFactor(0);
                this.add.text(300, 440, 'RETRY', {
                    fontSize: '28px',
                    fill: '#000',
                    fontStyle: 'bold'
                }).setOrigin(0.5).setScrollFactor(0);

                retryButton.setInteractive({ useHandCursor: true });
                retryButton.on('pointerover', () => { retryButton.fillColor = 0x00DD00; });
                retryButton.on('pointerout', () => { retryButton.fillColor = 0x00FF00; });
                retryButton.on('pointerdown', () => { this.scene.restart(); });

                const menuButton = this.add.rectangle(500, 440, 200, 60, 0xFF0000).setScrollFactor(0);
                this.add.text(500, 440, 'LEVEL SELECT', {
                    fontSize: '28px',
                    fill: '#FFF',
                    fontStyle: 'bold'
                }).setOrigin(0.5).setScrollFactor(0);

                menuButton.setInteractive({ useHandCursor: true });
                menuButton.on('pointerover', () => { menuButton.fillColor = 0xDD0000; });
                menuButton.on('pointerout', () => { menuButton.fillColor = 0xFF0000; });
                menuButton.on('pointerdown', () => { this.scene.start('LevelSelectScene'); });
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            backgroundColor: '#87CEEB',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 1000 },
                    debug: false
                }
            },
            scene: [MenuScene, LevelSelectScene, SkinsScene, GameScene]
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>
